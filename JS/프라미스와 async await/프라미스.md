# 프라미스



> 출처 - [**모던 JS 튜토리얼**](**https://ko.javascript.info/**) 을 보고 정리한 글입니다.



<br>



## 1. 프라미스(Promise) 객체

프라미스는 심한 콜백 중첩으로부터 발생하는 **콜백 지옥**을 해결할 수 있다. 


### 문법

```javascript
let promise = new Promise(function(resolve, reject) {
    // executor
});
```

- `executor` - 실행자, 실행 함수
  - `new Promise`에 전달되는 함수
  - `new Promise`가 만들어질 때 자동으로 실행된다.
  - `executor` 처리 성공 여부에 따라 `resolve`나 `reject` 중 하나를 반드시 호출한다.
  - **처리가 끝난 프라미스에 `resolve`와 `reject`를 호출하면 무시된다.**
- `resolve` / `reject`
  - 자바스크립트에서 자체 제공하는 콜백
  - `resolve(value)` - 일이 성공적으로 끝난 경우 그 결과를 나타내는 `value`와 함께 호출
  - `reject(error)` - 에러 발생 시 에러 객체를 나타내는 `error`와 함께 호출

<br>

### Promise 객체의 내부 프로퍼티

>  `new Promise` 생성자가 반환하는 `promise` 객체의 내부 프로퍼티

- `state` 

  - `pending(보류)` => `resolve` 호출 => `fulfilled`

  - `pending(보류)` => `reject` 호출 => `rejected`

- `result`
  - `undefined` => `resolve(value)` 호출 => `value`
  - `undefined` => `reject(error)` 호출 => `error`

<br>

### 예시

#### executor가 성공적으로 처리되었을 때

```javascript
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("성공"), 1000);
});
```

- 프라미스가 만들어지면 `executor` 함수는 자동으로 실행된다.
- `executor` 처리가 시작된 지 1초 후 `resolve("성공")`이 호출되고 결과가 만들어진다.
- 일이 성공적으로 처리되었을 때의 프라미스는 **fulfilled promise**라고 불린다.

#### executor가 제대로 처리되지 않았을 때

```javascript
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("에러 발생")), 1000);
});
```

- 1초 후 `reject(error)`가 호출되면 `promise`의 상태가 `rejected`로 변한다.
- 따로 에러 처리를 해주지 않았기 때문에 콘솔창에 `Uncaught` 에러가 발생한다.
- `resolved` 혹은 `rejected` 상태의 프라미스는 **settled promise(처리된 프라미스)** 라고 불린다.

<br>

## 2. 소비자: then, catch, finally

프라미스 객체는 `executor`와 결과나 에러를 받을 소비 함수를 이어주는 역할을 한다.

소비함수는 `.then`, `.catch`, `.finally` 메서드를 사용해 등록된다.

<br>

### (1) then

### 문법

```javascript
promise.then(
	function(result) { /* 결과(result) 다루기 */ },
    function(error) { /* 에러(error) 다루기 */ }
);
```

- `.then`의 인수
  - 첫 번째 인수 - 프라미스가 이행되었을 때 실행되는 함수
  - 두 번째 인수 - 프라미스가 거부되었을 때 실행되는 함수



### 예시

- 프라미스가 성공적으로 이행되었을 때

```javascript
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("성공"), 1000);
});

promise.then(
	result => alert(result), // 1초 뒤 '성공' 출력
    error => alert(error) // 실행되지 않음
);
```

- 프라미스가 거부되었을 때

```javascript
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("에러 발생")), 1000);
});

promise.then(
	result => alert(result), // 실행되지 않음
    error => alert(error) // 1초 후 'Error: 에러 발생' 출력
);
```

<br>

### (2) catch

```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("에러 발생")), 1000);
});

promise.catch(alert); // 1초 뒤 '에러 발생' 출력
```

- `.catch` 는 에러가 발생한 경우 `errorHandlingFunction`을 실행한다.
- .`catch(f)`는 `promise.then(null, f)`과 동일하게 작동한다.

- `promise.catch(alert)`은 `promise.catch((error) => alert(error))`와 같다.

<br>

### (3) finally

`try..catch`에서 `finally`절이 있는 것처럼 프라미스에도 `finally`가 있다.

```javascript
new Promise((resolve, reject) => {
  /* 시간이 걸리는 어떤 일을 수행하고, 그 후 resolve, reject를 호출 */
})
  // 성공·실패 여부와 상관없이 프라미스가 처리되면 실행됨
  .finally(() => 로딩 인디케이터 중지)
  .then(result => result와 err 보여줌 => error 보여줌)
```

- 쓸모가 없어진 로딩 인디케이터(loading indicator)를 멈추는 경우와 같이 결과에 상관없이 코드가 실행되어야 할 때 사용된다.
- `.finally(f)`는 `.then(f, f)`와 유사하지만 차이점이 존재한다.
  - `finally` 핸들러에는 인수가 없다.
  - `finally` 핸들러는 자동으로 다음 핸들러에 결과와 에러를 전달한다.
  - `.finally(f)`는 함수 `f`를 중복해서 쓸 필요가 없기 때문에 `.then(f, f)`보다 문법 측면에서 더 편리하다.

<br>

## 3. 예시: loadScript

> 콜백 기반으로 작성한 함수를 프라미스를 이용해 변경하기

```javascript
// 콜백 기반 함수 loadScript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

  document.head.append(script);
}

loadScript('1.js', function(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...
          }
        });
      }
    })
  }
});
```

```javascript
// 프라미스 사용
function loadScript(src) {
    return new Promise((resolve, reject) => {
       let script = document.createElemnt('script');
       script.src = src;
        
       script.onload = () => resolve(script);
       script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));
        
       document.head.append(script);
    })
}

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} 불러오기 성공`),
  error => alert(`Error: ${error.message}`)
);

promise.then(script => alert('또다른 핸들러...'));
```

<br>

## 4. 정리

| 프라미스                                                     | 콜백                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `loadScript(script)`로 스크립트를 읽고, 결과에 따라 `.then` 을 사용하여 무엇을 할지에 대한 코드를 작성하여 흐름이 자연스럽다. | `loadScript(script, callback)`를 호출할 때, 함께 호출할 `callback` 함수가 준비되어 있어야 한다. |
| 프라미스에 원하는 만큼 `.then`을 호출할 수 있다.             | 콜백은 하나만 가능하다.                                      |

