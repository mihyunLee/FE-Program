# 프라미스 체이닝



> 출처 - [**모던 JS 튜토리얼**](**https://ko.javascript.info/**) 을 보고 정리한 글입니다.



<br>



순차적으로 처리해야하는 비동기 작업이 여러 개 있을 때 프라미스를 사용하면 여러 가지 해결책을 만들 수 있다.

<br>

## 1. 프라미스 체이닝

```javascript
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1
  return result * 2;

}).then(function(result) {

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```

- 프라미스 체이닝은 `result`가 `.then` 핸들러의 체인을 통해 전달된다.
- `result`가 핸들러 체인을 따라 전달되므로, `alert` 창에 1, 2, 4가 순서대로 출력된다.
- `promise.then`을 호출하면 **프라미스가 반환**되기 때문에 프라미스 체이닝이 가능하다.

<br>

## 2. 프라미스 반환하기

`.then(handler)` 에 사용된 핸들러가 프라미스를 생성하거나 반환하는 경우도 있다.

이 경우 이어지는 핸들러는 프라미스가 처리될 때까지 기다리다가 처리가 완료되면 그 결과를 받는다.

```javascript
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1

  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 2

  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 4

});
```

- 위 코드는 이 전의 예시와 동일하게 동작하지만 얼럿 창 사이에 1초의 딜레이가 생긴다.

<br>

## 3. loadScript 예시 개선하기

```javascript
loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    // 스크립트 내의 함수 호출
    one();
    two();
    three();
  });
```

```javascript
// '.then' 바로 붙이기
loadScript("/article/promise-chaining/one.js").then(script1 => {
  loadScript("/article/promise-chaining/two.js").then(script2 => {
    loadScript("/article/promise-chaining/three.js").then(script3 => {
      one();
      two();
      three();
    });
  });
});
```

- `.then`을 바로 붙이게 되도 원래의 코드와 동일하게 동작한다.
- 하지만, 코드가 오른쪽으로 길어져 콜백에서 언급한 콜백 지옥과 동일한 문제가 발생한다.

<br>

## 👁️‍🗨️ thenable

> **thenable 객체**
>
> `.then`이라는 메서드를 가진 객체를 모두 `thenable` 객체라고 부른다.
>
> 핸들러는 프라미스가 아닌 `thenable` 객체를 반환하기도 한다.
>
> 서드파티 라이브러리가 프라미스와 호환 가능한 자체 객체를 구현할 수 있다는 점에서 나왔고, 이 객체들에는
>
> `.then`이 있기 때문에 네이티브 프라미스와도 호환 가능하다.

### 예시

```javascript
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    setTimeout(() => resolve(this.num * 2), 1000);
  }
}

new Promise(resolve => resolve(1))
  .then(result => {
    return new Thenable(result);
  })
  .then(alert); // 1000밀리 초 후 2를 보여줌
```

위와 같이 구현하면 `Promise`를 상속받지 않고도 커스텀 객체를 사용해 프라미스 체이닝을 만들 수 있다.

<br>

## 5. fetch와 체이닝 함께 응용하기

> **fetch**
>
> 서버에 네트워크 요청을 보내고 새로운 정보를 받아올 때 사용한다.

### 문법

```javascript
let promise = fetch(url, [options]);
```

- `url`
  - 접근하고자 하는 URL
- `options`
  - 선택 매개변수, `method `나 `header `등을 지정할 수 있다.

위 코드를 실행하면 `url`에 네트워크 요청을 보내고 프라미스를 반환한다. 원격 서버가 헤더와 함께 응답을 보내면, 프라미스는 `response` 객체와 함께 이행된다.

그런데 이 때 **response 전체가 완전히 다운로드 되기 전**에 프라미스는 이행 상태가 되어버린다.

응답이 완전히 종료되고, 응답 전체를 읽으려면 메서드 `response.text()`를 호출해야 한다.

`response.text()`는 원격 서버에서 전송한 텍스트 전체가 다운로드 되면, 이 텍스트를 `result` 값으로 갖는 이행된 프라미스를 반환한다.

### 예시

```javascript
fetch('/article/promise-chaining/user.json')
  // 원격 서버가 응답하면 .then 아래 코드가 실행된다.
  .then(function(response) {
    // response.text()는 응답 텍스트 전체가 다운로드되면
    // 응답 텍스트를 새로운 이행 프라미스를 만들고, 이를 반환한다.
    return response.text();
  })
  .then(function(text) {
    // 원격에서 받아온 파일의 내용
    alert(text); // {"name": "Violet-Bora-Lee", "isAdmin": true}
  });
```

### response.json()을 사용하기

`response.json()`을 사용하면 원격에서 받아온 데이터를 읽고 JSON으로 파싱할 수 있다.

```javascript
// 위 코드와 동일한 기능을 하지만, response.json()은 원격 서버에서 불러온 내용을 JSON으로 변경해준다.
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // Violet-Bora-Lee
```