# 콜백



> 출처 - [**모던 JS 튜토리얼**](**https://ko.javascript.info/**) 을 보고 정리한 글입니다.



<br>



자바스크립트 호스트 환경이 제공하는 여러 함수를 사용하면 ***비동기(asynchronous)** 동작을 스케줄링 할 수 있다. 

> **비동기 동작**
>
> 비동기(asynchronous)는 동시에 일어나지 않는것을 의미한다.
>
> 요청과 결과가 동시에 일어나지 않고, 하나의 요청을 처리하면서 다른 작업을 같이 할 수 있어 자원을 효율적으로 사용할 수 있다.

- `setTimeout` - 스케줄링에 사용되는 대표적인 함수
- 스크립트나 모듈을 로딩하는 것도 비동기 동작에 속한다.

<br>

## 1. 비동기 동작 예시

```javascript
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
```

- `loadScript()` - `<script src = "...">`를 동적으로 만들고 이를 문서에 추가하는 함수

<br>

#### loadScript(src) 사용법

```javascript
// 해당 경로에 위치한 스크립트를 불러오고 실행
loadScript('/my/script.js');
```

- 이 때 스크립트는 **비동기적으로** 실행된다.
- 로딩이 당장 시작되더라도 실행은 함수가 끝난 후에 되기 때문에 `loadScript(...)` 아래에 있는 코드들은 스크립트 로딩이 종료되는 걸 기다리지 않는다.



#### 에러가 나는 경우

```javascript
loadScript('/my/script.js'); // script.js에 newFunction()이 존재한다고 가정

newFunction(); // 함수가 존재하지 않는다는 에러가 발생
```

- 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문에 에러가 발생한다.
- `loadScript`에서 스크립트가 로드되고 실행도 되지만, 스크립트 로딩 완료 시점을 알 수 없다.
- 따라서 `loadScript`의 두 번째 인수로 스크립트 로딩이 끝난 후 실행될 *`콜백(callback)` 함수를 추가한다.

> **콜백(callback) 함수**
>
> 다른 코드의 인수로서 넘겨주는 실행 가능한 코드이다.
>
> 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 나중에 실행할 수도 있다.



#### 콜백 함수 사용하여 코드 수정하기

```javascript
function loadScript(src, callback){
    let script = document.createElement('script');
    script.src = src;
    
    script.onload = () => callback(script);
    
    document.head.append(script);
}

loadScript('/my/script.js', function(){
    newFunction();
    ...
})
```

- 새롭게 불러온 스크립트에 있는 함수를 콜백 함수 안에서 호출하면 원하는 대로 외부 스크립트 안의 함수를 사용할 수 있다.
- `loadScript`의 두 번째 인수로 전달된 함수(대게 익명 함수)는 외부 스크립트 로딩이 완료되었을 때 실행된다.

이런 방식을 **콜백 기반(callback-based) 비동기 프로그래밍**이라고 한다.

무언가를 비동기적으로 수행하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 `콜백`을 인수로 반드시 제공해야 한다.

<br>

## 2. 콜백 속 콜백

#### 스크립트가 두 개 있는 경우 스크립트 순차적으로 불러오기

스크립트를 순차적으로 불러오기 위해서는 콜백 함수 안에 두 번째 `loadScript`를 호출하는 방법이 있다.

```javascript
loadScript('/my/script.js', function(script){
    alert(`${script.src}을 로딩했습니다. 이젠, 다음 스크립트를 로딩합시다.`);
    
    loadScript('/my/script.js', function(script){
        alert(`두 번째 스크립트를 성공적으로 로딩했습니다.`);
    });
});
```

위와 같이 **중첩 콜백**을 만들면 바깥에 위치한 `loadScript`가 완료된 후, 안쪽 `loadScript`가 실행된다.

하지만 스크립트 갯수가 늘어나면 중첩이 많아지기 때문에 좋지 않다.

<br>

## 3. 에러 핸들링

```javascript
function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    
    script.onload = () => callback(null, script);
    script.onerror = () => callback(new Error(`${src}를 불러오는 도중 에러가 발생했습니다.`));
    
    document.head.append(script);
}

loadScript('/my/script.js', function(error, script){
    if (error){
        // 에러 처리
    } else{
        // 스크립트 로딩이 성공적으로 끝남
    }
})
```

위 코드는 스크립트 로딩 시 에러를 처리하는 흔한 방식이다. 이런 패턴을 **오류 우선 콜백(error-first callback)** 이라고 부른다.



#### 오류 우선 콜백

**오류 우선 콜백** 스타일을 사용하면 단일 `콜백` 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.

1. `callback`의 첫 번째 인수는 에러로 사용된다. 에러가 발생하면 이 인수를 이용해 `callback(err)`이 호출된다.
2. 두 번째 인수는 에러가 발생하지 않았을 때 사용된다. 원하는 동작이 성공한 경우엔 `callback(null, result1, result2, ...)`이 호출된다.

<br>

## 4. 멸망의 피라미드

> 콜백 지옥(callback hell) / 멸망의 피라미드(pyramid of doom)

콜백 기반 비동기 처리는 호출이 중첩되면서 코드가 깊어질 수 있다. 이러한 깊은 중첩 코드가 만들어 내는 패턴을 **콜백 지옥** 혹은 **멸망의 피라미드**라고 부른다.

```javascript
// 깊은 중첩 코드
loadScript('1.js', function(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...
          }
        });
      }
    })
  }
});
```

<br>

#### 콜백 지옥 해결하기

```javascript
loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // 모든 스크립트가 로딩되면 다른 동작을 수행한다.
  }
};
```

- 각 동작을 독립적인 함수로 만들어 문제를 해결할 수 있다.
- 하지만 코드의 가독성이 떨어지고 `stepN` 함수들은 콜백 지옥을 피하기 위한 용도로 만들어져 재사용이 불가능하다.
- 위 방법 외에도 **프라미스**(promise)를 사용하면 콜백 지옥을 피할 수 있다.

