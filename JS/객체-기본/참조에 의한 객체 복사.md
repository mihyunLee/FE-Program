# 참조에 의한 객체 복사



> 출처 - [**모던 JS 튜토리얼**](******https://ko.javascript.info/******) 을 보고 정리한 글입니다.



<br>



## 1. 참조에 의한 객체 복사

`원시값`(문자열, 숫자, 불린 값)은 **값 그대로 저장, 할당**되고 복사되는 반면, `객체`는 **참조에 의해**(by reference) 저장되고 복사된다.



```javascript
let message = "Hello!";
let phrase = message;
```

위 예시는 두 개의 독립된 변수에 각각 문자열 `"Hello!"`가 저장된다.

<br>

```javascript
let user = { name: "John" };

let admin = user; // 참조값 복사
```

객체는 메모리 내 어딘가에 저장되고, 변수 `user`엔 객체를 **참조할 수 있는 값**이 저장된다.

따라서 **객체가 할당된 변수를 복사할 때는 객체의 참조 값이 복사되고 객체는 복사되지 않는다.**

예시의 변수는 user, admin 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장된다.

<br>

```javascript
let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨

alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인
```

`user`와 `admin`은 같은 객체에 대한 **참조 값**이 저장되어 있다.  
따라서 하나의 프로퍼티 값을 변경했을 때 `user`와 `admin` 두 객체 모두 변경된 값을 확인할 수 있다.

<br>

### 참조에 의한 비교

객체 비교 시 동등 연산자(`==`)와 일치 연산자(`===`)는 동일하게 동작한다.

비교 시 피연산자인 **두 객체가 동일한 객체인 경우에 참을 반환**한다.

```javascript
let a = {};
let b = a; // 참조에 의한 복사

alert(a == b); // true
alert(a === b); // true

let c = {};
let d = {};

alert(a == b); // false
```

객체 `b`의 경우 객체 `a`의 참조 값이 할당되어서 동일한 객체를 가르키고 있지만,

객체 `c`와 `d`는 서로 다른 객체이므로 `false`가 반환된다.



> `obj1 > obj2` 같은 대소 비교나 `obj == 5` 같은 원시값과의 비교에선 객체가 원시형으로 변환된다.
>
> 이러한 비교가 필요한 경우는 매우 드문 경우이고, 대개 코딩 실수 때문에 이런 비교가 발생한다.

<br>

## 2. 객체 복사, 병합과 Object.assign

### 객체의 참조 값이 아닌 **독립적인 객체로 복사**하고 싶은 경우

1. 새로운 객체를 만든 다음, 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사한다.

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사한다.
for (let key in user) {
  clone[key] = user[key];
}

clone.name = "Pete"; // clone의 데이터를 변경한다.

alert(user.name); // 기존 객체에는 여전히 John이 있다.
```

<br>

2. `Object.assign()` 메서드 사용하기

```javascript
Object.assign(dest, [src1, src2, src3...])
```

- `dest` : 복사한 내용을 반영할 객체
- `src1, ..., srcN` : 복사하고자 하는 객체

`Object.assign`은 객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사한 후 `dest`를 반환한다.

`dest`에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 덮어씌워진다.

<br>

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
```

위의 예시처럼` Object.assign`을 사용하면 반복문 없이 `clone`에 ` user`를 복제할 수 있다.

<br>

## 3. 중첩 객체 복사

객체의 프로퍼티가 원시값이 아닌 다른 객체에 대한 참조 값이 있을 경우의 객체 복사는 어떻게 될까?

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체

// user와 clone는 sizes를 공유한다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있다.
```

`user.sizes`는 객체이기 때문에 `clone.sizes`에는 `user.sizes`의 참조 값이 복사된다.

따라서, `user.sizes`와 `clone.sizes`는 같은 객체를 공유한다.

이러한 상황에서의 복사를 `깊은 복사`(deep cloning)이라 하고, [Structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)이나 자바스크립트 라이브러리 lodash의 메서드인 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하여 처리할 수 있다.