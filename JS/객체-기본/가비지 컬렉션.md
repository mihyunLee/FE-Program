# 가비지 컬렉션



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



자바스크립트는 **메모리 관리**를 수행한다. 원시값, 객체, 함수 등 우리가 만드는 모든 것은 메모리를 차지하기 때문에 쓸모 없어지게 된 것들은 메모리에서 삭제되어야 한다.

<br>

## 1. 가비지 컬렉션 기준

자바스크립트는 *도달 가능성(reachability)* 개념을 사용해 메모리 관리를 수행한다.

도달 가능한 값은 **어떻게든 접근하거나 사용할 수 있는 값**을 의미하며 도달 가능한 값은 메모리에서 삭제되지 않는다.

1. 태생부터 도달 가능한 값으로, 명백한 이유 없이는 삭제되지 않는다.

   - 현재 함수의 지역 변수와 매개변수
   - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
   - 전역 변수
   - 등등

   위의 값들은 ***루트(root)*** 라고 부른다.

2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.

**가비지 컬렉션**은 자바스크립트 엔진 내에서 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제한다.

<br>

### 예시

```javascript
// user엔 객체 참조 값이 저장된다.
let user = {
    name: "John"
};
```

전역 변수 `user`는 `{name: "John"}`이라는 객체를 참조한다. 객체의 프로퍼티 `name`은 원시값을 저장하고 있기 때문에 객체 안에 표현했다.

<br>


```javascript
user = null;
```

`user`의 값을 다른 값으로 덮어쓰면 참조가 사라진다. `{name: "John"}` 에 접근할 수 있는 방법도 없어지기 때문에 가비지 컬렉터는 객체에 저장된 데이터를 삭제하고, 객체를 메모리에서 삭제한다.

<br>

## 2. 참조가 두 개인 경우

```javascript
let user = {
  name: "John"
};

let admin = user;

user = null;
```

현재 `user`와 `admin`은 같은 객체를 참조하고 있다. 이 때, `user`의 값을 다른 값으로 덮어쓸 경우, `user`에서는 객체를 접근할 수 없게 되지만 `admin`을 통해서는 객체에 접근할 수 있다.

따라서 객체는 메모리에서 삭제되지 않고, `admin`을 다른 값으로 덮어쓰게 되면 메모리에서 삭제될 수 있다.

<br>

## 3. 연결된 객체

```javascript
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
```

- `family`는 marry 함수가 반환하는 새로운 객체를 참조하고 있다.
- 반환하는 새로운 객체에서 `father`는 매개변수로 받은 `name: "John"`을, `mother`는  `name: "Ann"`을 참조하고 있다.
- `name: "John"`의 프로퍼티인 `wife`는 `name: "Ann"`을, `name: "John"`의 프로퍼티인 `husband`는 `name: "John"`을 참조하고 있다.

메모리 구조는 아래와 같이 나타낼 수 있다.

![image](https://user-images.githubusercontent.com/51310674/179995659-54c3a6cc-cbe9-45d4-81ac-ea7a52b44d29.png)

<br>

### 참조를 삭제했을 경우

```javascript
delete family.father;
delete family.mother.husband;
```

위와 같이 두 개의 참조를 삭제했을 경우 John으로 들어오는 참조는 모두 사라져 John은 도달 가능한 상태에서 벗어난다.

외부로 나가는 참조는 도달 가능한 상태에 영향을 주지 않기 때문에 John은 메모리에서 제거되고, 저장된 데이터(프로퍼티)도 메모리에서 없어진다.

<br>

### 근원 객체가 삭제될 경우

객체들이 섬 같은 구조로 연결되어 있을 때, 근원 객체 `family`가 아무것도 참조하지 않도록 한다.

```javascript
family = null;
```

`family` 객체와 루트의 연결이 사라지면 루트 객체를 참조하는 것이 없어진다.

따라서 섬 구조 전체에 도달할 수 없게 되고, 섬을 구성하는 객체 전부가 메모리에서 제거된다.

<br>

## 4. 내부 알고리즘

가비지 컬렉션의 기본 알고리즘은 `mark-and-sweep`이라 불린다.

가비지 컬렉션의 알고리즘은 2가지 기본 작업을 수행해야 한다.

1. 도달할 수 없는 모든 개체를 감지할 수 있어야 한다.
2. 가비지 개체가 사용하는 공간을 회수하고, 해당 공간을 프로그램에서 다시 사용할 수 있도록 해야한다.

<br>

### 수행 단계

1. 가비지 컬렉터는 루트 정보를 수집하고 이를 `mark`(기억)한다.
2. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 `mark`한다.
3. `mark` 된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 `mark `한다.
4. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다.
5. `mark` 되지 않은 객체는 도달 가능한 값이 아니므로 메모리에서 삭제한다.

<br>

## 5. 가비지 컬렉션을 더 빠르게 하는 최적화 기법

- **generational collection(세대별 수집)**
  - 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어진 객체를 `새로운 객체`로 구분하고, 일정 시간 이상 동안 살아남은 객체는 `오래된 객체`로 분류한다.
  - `새로운 객체`는 공격적으로 메모리에서 제거하고, `오래된 객체`는 덜 감시한다.
- **incremental collection(점진적 수집)**
  - mark할 객체가 많아지면 많은 시간이 소모된다.
  - 자바스크립트 엔진은 이러한 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행한다.
  - 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있다.
- **idle-time collection(유휴 시간 수집)**
  - 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행한다.

> 유휴 상태란?

어떠한 프로그램에 의해서도 사용되지 않는 상태. CPU가 모든 태스크를 끝내면 유휴 상태가 된다.
