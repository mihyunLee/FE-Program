# 커스텀 에러와 에러 확장



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



> 커스텀 에러를 사용하는 경우

`HttpError`, `DbError`, `NotFoundError` 등 에러 클래스가 직관적이기 때문에 종종 사용한다.

커스텀 에러 클래스들은 `message`나 `name`, 가능하다면 `stack` 프로퍼티를 지원해야한다.

`throw` 인수엔 제약이 없기 때문에 커스텀 에러 클래스는 반드시 `Error`를 상속할 필요가 없다. 그렇지만 `Error`를 상속받아 커스텀 에러 클래스를 만들게 되면 `obj instanceof Error`로 에러 객체를 식별할 수 있다는 장점이 생긴다.

따라서 `Error`를 상속받아 에러 객체를 만드는 것이 좋다.

<br>

## 1. 에러 확장하기

### 커스텀 에러 클래스 생성

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function test() {
  throw new ValidationError("에러 발생!");
}

try {
  test();
} catch(err) {
  alert(err.message); // 에러 발생!
  alert(err.name); // ValidationError
  alert(err.stack); // 각 행 번호가 있는 중첩된 호출들의 목록
}
```

- `class ValidationError extends Error`
  - `Error`를 상속받음 
- `super(message)`
  - 자바스크립트에서는 자식 생성자 안에서 `super`를 반드시 호출해야 한다.
  - `message` 프로퍼티는 부모 생성자에서 설정된다.
- `this.name = "ValidationError"`
  - 부모 생성자에선 `message` 뿐만 아니라 `name` 프로퍼티도 설정하기 때문에 원하는 값으로 재설정

<br>

### 커스텀 에러 클래스 사용하기

```javascript
// 커스텀 에러 클래스 생성
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// 커스텀 에러 클래스 사용
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("No field: age");
  }
  if (!user.name) {
    throw new ValidationError("No field: name");
  }

  return user;
}

// try..catch와 readUser를 함께 사용한 예시

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Invalid data: " + err.message); // Invalid data: No field: name
  } else if (err instanceof SyntaxError) { 
    alert("JSON Syntax Error: " + err.message);
  } else {
    throw err; // 알려지지 않은 에러는 재던지기 하기
  }
}
```

<br>

### 에러 유형 확인을 하는 또 다른 방법 - err.name

```javascript
// ...
// (err instanceof SyntaxError) 대신 사용 가능
} else if (err.name == "SyntaxError") {
// ...
```

`instanceof` 대신에 `err.name`으로 에러 유형을 확인할 수도 있다. 하지만 `err.name`보다는 `instanceof`를 사용하는 것이 좋다.

커스텀 에러 클래스를 확장하여 새로운 확장 에러를 만들게 될 때, `instanceof`는 새로운 상속 클래스에서도 동작하기 때문이다.

<br>

## 2. 더 깊게 상속하기

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// 에러 확장
class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.name = "PropertyRequiredError";
    this.property = property;
  }
}

function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new PropertyRequiredError("age");
  }
  if (!user.name) {
    throw new PropertyRequiredError("name");
  }

  return user;
}

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Invalid data: " + err.message); // Invalid data: No property: name
    alert(err.name); // PropertyRequiredError
    alert(err.property); // name
  } else if (err instanceof SyntaxError) {
    alert("JSON Syntax Error: " + err.message);
  } else {
    throw err;
  }
}
```

`PropertyRequiredError`는 `ValidationError`를 상속받아 확장시켰기 때문에 `message`는 생성자가 알아서 만들어준다.

다만, 이렇게 매번 커스텀 에러 클래스의 생성자 안에서 `this.name`을 수동으로 할당해주는 것은 귀찮은 작업이다. 따라서 기본 에러 클래스를 만들고 커스텀 에러들이 이 클래스를 상속받게 하는 것도 좋다.

<br>

### 기본 에러 클래스 만들기

```javascript
class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

class ValidationError extends MyError { }

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.property = property;
  }
}

alert( new PropertyRequiredError("field").name ); // PropertyRequiredError
```

기본 에러 클래스에 `message`와 `name`을 설정하는 코드를 넣어주면 커스텀 에러의 생성자 코드가 깔끔해진다.

<br>

## 3. 예외 감싸기

#### 에러 처리 스키마

```javascript
try {
  ...
  readUser()  // 잠재적 에러 발생처
  ...
} catch (err) {
  if (err instanceof ValidationError) {
    // validation 에러 처리
  } else if (err instanceof SyntaxError) {
    // 문법 에러 처리
  } else {
    throw err; // 알 수 없는 에러는 다시 던지기 함
  }
}
```

현재 코드에서는 `readUser` 기능이 커지면서 에러의 종류가 늘어날수록 에러 처리 분기문이 점점 길어질 수 있다.

하지만 실제 우리가 필요한 정보는 데이터를 읽을 때 에러가 발생했는지에 대한 여부이다. 왜 에러가 발생했는지와 자세한 설명은 대부분 필요하지 않다.

이때 종류별 에러를 좀 더 추상적인 에러에 하나로 모아 처리하는 에러 처리 기술을 **예외 감싸기(wrapping exception)** 라고 한다.

<br>

### 예외 감싸기 동작

1. `데이터 읽기`와 같은 포괄적인 에러를 대변하는 새로운 클래스 `ReadError`를 만든다.
2. 함수 `readUser`에서 발생한 `ValidationError`, `SyntaxError`등의 에러는 `readUser` 내부에서 잡고 이때 `ReadError`를 생성한다.
3. `ReadError` 객체의 `cause` 프로퍼티엔 실제 에러에 대한 참조가 저장된다.

예외 감싸기 기술을 사용하여 스키마를 변경하게 되면 `readUser`를 호출하는 코드에선 `ReadError`만 확인하면 되고, 추가 정보가 필요한 경우엔 `cause` 프로퍼티를 확인하면 된다.

<br>

### 예외 감싸기 구현

```javascript
class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}

class ValidationError extends Error { /*...*/ }
class PropertyRequiredError extends ValidationError { /* ... */ }

function validateUser(user) {
  if (!user.age) {
    throw new PropertyRequiredError("age");
  }

  if (!user.name) {
    throw new PropertyRequiredError("name");
  }
}

function readUser(json) {
  let user;

  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new ReadError("Syntax Error", err);
    } else {
      throw err;
    }
  }

  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ReadError("Validation Error", err);
    } else {
      throw err;
    }
  }

}

try {
  readUser('{잘못된 형식의 json}');
} catch (e) {
  if (e instanceof ReadError) {
    alert(e);
    // Original error: SyntaxError: Unexpected token b in JSON at position 1
    alert("Original error: " + e.cause);
  } else {
    throw e;
  }
}
```

- `readUser`에서 Syntax 에러나 Validation 에러가 발생한 경우 해당 에러 자체가 아닌 `ReadError`를 던진다.
- `readUser`를 호출하는 바깥 코드에서는 `instanceof ReadError` 하나만 확인한다.



