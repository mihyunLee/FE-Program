# 문자열



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



## 1. 문자열 표현 방식

- 작은 따옴표(`"`)
- 큰 따옴표(`'`)
- 백틱(`)
  - 문자열 중간에 `${..}` 로 표현식을 감싸 표현식과 문자열을 같이 표현할 수 있다.
  - 이러한 방식을 `템플릿 리터럴`이라고 부른다.

<br>

## 2. 특수 기호

문자열 안에서 동작하는 특수 문자들이 있다.

| 특수 문자                                            | 설명                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| `\n`                                                 | 줄 바꿈                                                      |
| `\r`                                                 | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꾼다. 캐리지 리턴을 단독으론 사용하는 경우는 없다. |
| `\'`, `\"`                                           | 따옴표                                                       |
| `\\`                                                 | 역슬래시                                                     |
| `\t`                                                 | 탭                                                           |
| `\b`, `\f`, `\v`                                     | 각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타낸다. 호환성 유지를 위해 남아있는 기호로 요즘엔 사용하지 않는다. |
| `\xXX`                                               | 16진수 유니코드 `XX`로 표현한 유니코드 글자.<br />(예시: 알파벳 `'z'`는 `'\x7A'`와 동일함) |
| `\uXXXX`                                             | UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호. `XXXX`는 반드시 네 개의 16진수로 구성되어야 한다.<br />(예시: `\u00A9`는 저작권 기호 `©`의 유니코드임). |
| `\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지한다. 이 방법을 사용하면 긴 코드를 삽입할 수 있다. |

<br>

## 3. 문자열의 길이

`length` 프로퍼티엔 문자열의 길이가 저장된다.

```javascript
alert(`My\n`.length) // 3
```

`\n`은 특수 문자 하나로 취급되기 때문에 문자열의 길이는 `3`이 반환된다.

<br>

## 4. 특정 글자에 접근하기

- 대괄호`[]` 로 접근하기

  - `[]`는 접근하려는 위치에 글자가 없는 경우 undefined를 반환한다.

  ```javascript
  let str = "Hello";
  
  alert(str[0]); // H
  alert(str[100]); // undefined
  ```

- `str.charAt()` 메서드 사용하기

  - `charAt`은 접근하려는 위치에 글자가 없는 경우 빈 문자열을 반환한다.

  ```javascript
  let str = "Hello";
  
  alert(str.charAt(0)); // H
  alert(str.charAt(100)); // ''
  ```

- `for..of`

  - 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.

  ```javascript
  for (let char of "Hello") {
    alert(char); // H,e,l,l,o (char는 순차적으로 H, e, l, l, o가 된다.)
  }
  ```

<br>

## 5. 문자열의 불변성

문자열은 수정할 수 없다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

```javascript
let str = "Hi";

str[0] = 'h'; // Error: Cannot assign to read only property '0' of string 'Hi'
alert(str[0]); // 동작하지 않음
```



이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 된다.

```javascript
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체

alert( str ); // hi
```

<br>

## 6. 대소문자 변경하기

- `toLowerCase()`
  - 대문자를 소문자로 변경
- `toUpperCase()`
  - 소문자를 대문자로 변경

글자 하나의 케이스만 변경하는 것도 가능하다.

원시값의 메서드를 확인해보면 `toUpperCase`와 `toLowerCase`는 특별한 객체를 만들어 변경한 문자열을 반환하고 특별한 객체를 파괴하기 때문에 하나의 케이스도 변경이 가능한 것이다.

```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

alert( 'Interface'[0].toLowerCase() ); // 'i'
```

<br>

## 7. 부분 문자열 찾기

### str.indexOf

- `str.indexOf(substr, [pos])`
  - `str`의 `pos`에서부터 부분 문자열 `substr`가 발견되는 **첫 번째 위치**를 반환한다.
  - `pos`는 필수 매개변수는 아니다.
  - 원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 `-1`을 반환한다.

```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0
alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따진다.

alert( str.indexOf("id") ); // 1, Widget의 id가 있는 위치
alert( str.indexOf("id", 2)); // 12
```



### str.lastIndexOf

- `str.lastIndexOf(substr, [pos])`
  - 문자열 끝에서부터 부분 문자열을 찾는다.
  - `str`의 `pos`에서부터 `substr`이 마지막으로 발견되는 인덱스를 반환한다.



### 비트 NOT 연산자를 사용한 기법

- 비트 NOT 연산자 (`~`)
  - 피연산자를 32비트 정수로 바꾼 후 모든 비트를 반전한다.
  - `n`이 32비트 정수일 때 `~n`은 `-(n+1)`이 된다.
  - 문자열이 `4294967295`보다 큰 경우에는 `~` 연산자가 의도한 대로 작동하지 않는다.

```javascript
let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( '찾았다!' );
}
```

`str.indexOf("Widget")`이 `-1`이 되면 `~str.indexOf("Widget")`은 `0`이 되므로 if문 안의 코드가 실행되지 않는다.

따라서 `if(~str.indexOf("Widget"))`와 `if(str.indexOf("Widget") !== -1) `은 동일하게 동작한다.



### includes, startsWith, endsWith

- `str.includes(substr, pos)`
  - `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환한다.
  - 부분 문자열의 위치보다는 포함 여부만 알고 싶을 때 적합하다.
- `str.startsWith` / `str.endsWith`
  - 문자열 `str`이 특정 문자열로 시작하는지 여부와 특정 문자열로 끝나는지 여부를 확인할 때 사용할 수 있다.

<br>

## 8. 부분 문자열 추출하기

- `str.slice(start [, end])`
  - 문자열의 `start`부터 `end`까지(`end`는 미포함)를 반환한다.
  - 두 번쨰 인수가 생략된 경우 명시한 위치부터 문자열 끝까지를 반환한다.
  - `start`와 `end`가 음수일 경우 문자열 끝에서부터 카운트한다.
- `str.substring(start, [, end])`
  - `start`와 `end` 사이에 있는 문자열을 반환한다.
  - `slice`와 유사하지만 `start`가 `end`보다 커도 괜찮다는 차이가 있다.
  - 음수 인수는 `0`으로 처리된다.
- `str.substr(start [, length])`
  - `start`에서부터 시작해 `length` 개의 글자를 반환한다.

| 메서드                  | 추출할 부분 문자열                    | 음수 허용 여부(인수)  |
| ----------------------- | ------------------------------------- | --------------------- |
| `slice(start, end)`     | `start`부터 `end`까지(`end`는 미포함) | 음수 허용             |
| `substring(start, end)` | `start`와 `end` 사이                  | 음수는 `0`으로 취급함 |
| `substr(start, length)` | `start`부터 `length`개의 글자         | 음수 허용             |

<br>

## 9. 문자열 비교하기

모든 문자열은 UTF-16을 사용해 인코딩되는데, UTF-16에선 모든 글자가 숫자 형식의 코드와 매칭된다.

- `str.codePointAt(pos)`

  - `pos`에 위치한 글자의 코드를 반환한다.

  ```javascript
  alert( "z".codePointAt(0) ); // 122
  alert( "Z".codePointAt(0) ); // 90
  ```

- `String.fromCodePoint(code)`

  - 숫자 형식의 `code`에 대응하는 글자를 만들어준다.

  ```javascript
  alert( String.fromCodePoint(90) ); // Z
  ```

- `\u`뒤에 16진수 코드를 붙여서 글자 만들기

  ```javascript
  // 90을 16진수로 변환하면 5a
  alert( '\u005a' ); // Z
  ```



### localCompare()

`str.localCompare(str2)`를 호출하면 ECMA-402에서 정의한 규칙에 따라 `str`과 `str2`를 비교하여 정수가 반환된다.

- `str < str2` : 음수
- `str > str2` : 양수
- `str === str2` : 0

[localCompare](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)에는 기준이 되는 언어를 지정해주는 인수와 대·소문자를 구분할지, `"a"`와 `"á"`를 다르게 취급할지에 대해 설정해주는 선택적 인수가 두 개 더 존재한다.

<br>

> **`String.fromCharCode` / `str.charCodeAt` Vs. `String.fromCodePoint` / `str.codePointAt`**

2바이트 코드로 이루어진 글자들은 현존하는 기호를 모두 표현하기에 충분하지 않다.

따라서 사용 빈도가 낮은 기호는 ***서로게이트 쌍***이라 불리는 2바이트 글자들의 쌍을 사용해 인코딩한다. (ex. 𝒳, 👍, 𩷶 등)

`String.fromCodePoint` 와 `str.codePointAt`은 명세서에 추가된 지 얼마 안 된 메서드로 서로게이트 쌍을 제대로 처리할 수 있다.

두 메서드가 등장하기 전에는 [String.fromCharCode](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)와 [str.charCodeAt](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt) 을 사용했었고, 이 메서드들은 서로게이트 쌍을 처리하지 못한다.