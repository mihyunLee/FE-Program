# 배열과 메서드



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



## 1. 요소 추가·제거 메서드

### splice

배열은 객체에 속하므로 객체에서 요소를 지우는 메서드인 `delete`를 사용하여 요소를 지울 수도 있다.

하지만 `delete`는 `key`를 이용해 해당 키에 상응하는 **값**을 지우기 때문에 배열 요소의 값만 사라지고, 배열의 길이는 변하지 않는다.

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // "go"를 삭제합니다.

alert( arr ); // I,,home

alert( arr.length ); // 3
```

<br>

`splice` 메서드는 요소를 추가, 삭제, 교체가 모두 가능하다.

```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

- `index` 
  - 메서드를 적용할 첫 번째 시작 인덱스
  - 음수 인덱스 사용 가능
- `deleteCount` 
  - 제거하고자 하는 요소의 개수
  - `0`으로 설정 후 `elem1, ..., elemN` 인수를 넘겨주면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.
- `elem1, ..., elemN` 
  - 배열에 추가할 요소

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

arr.splice(1, 1); // 인덱스 1부터 1개의 요소 삭제

alert(arr); // ["I", "JavaScript", "right", "now"]

arr.splice(0, 2, "Let's", "dance"); // 인덱스 0부터 2개의 요소 삭제 후, 해당 자리를 다른 요소로 교체

alert(arr); // ["Let's", "dance", "right", "now"]
```

<br>

`splice`는 삭제된 요소로 구성된 배열을 반환한다.

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음 두 개의 요소를 삭제함
let removed = arr.splice(0, 2);

alert(removed); // "I", "study" 
```

<br>

### slice

`arr.slice`는 `start` 인덱스부터 `end`를 제외한 `end` 인덱스까지의 요소를 복사한 새로운 배열을 반환한다.

```javascript
arr.slice([start], [end])
```

`arr.slice`는 문자열 메서드인 `str.slice`와 유사하게 동작하는데 서브 문자열 대신 서브 배열을 반환한다는 차이가 있다.



```javascript
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s

alert( arr.slice(-2) ); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지 복사)
```

인수를 넘기지 않고 호출한  `arr.slice()`는 `arr`의 복사본을 만들 수 있다.

<br>

### concat

`arr.concat`은 기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용할 수 있다.

```javascript
arr.concat(arg1, arg2 ...)
```

메서드를 호출하면 `arr`에 속한 모든 요소와 `arg1`, `arg2` 등에 속한 모든 요소를 합친 새로운 배열이 반환된다.

인수 `argN`가 배열일 경우 배열의 모든 요소가 복사되고, 단순 값인 경우는 인수가 그대로 복사된다.

```javascript
let arr = [1, 2];

alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

<br>

객체가 인자로 넘어오면 객체는 분해되지 않고 통으로 복사되어 더해진다.

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

<br>

인자로 받은 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 이 객체를 배열처럼 취급해 객체 프로퍼티 값이 더해진다.

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

<br>

## 2. forEach로 반복작업 하기

```javascript
arr.forEach(function(item, index, array) {
  // 각각의 요소에 대해 실행할 함수
});
```

<br>

## 3. 배열 탐색하기

### indexOf, lastIndexOf, includes

- `arr.indexOf(item, from)`
  - 인덱스 `from`부터 시작해 `item`을 찾아서 배열에서 `item`을 발견하면 해당 요소의 인덱스를 반환하고, 그렇지 않으면 `-1`을 반환한다.

- `arr.lastIndexOf(item, from)`
  - `indexOf` 메서드와 동일한 기능을 하는데, 검색을 끝에서부터 시작한다.
- `arr.includes(item, from)`
  - 인덱스 `from`부터 시작해 `item`을 검색해서 해당 요소를 발견하면 `true`를 반환한다.

위의 세 메서드는 요소를 찾을 때 완전 항등 연산자 `===`를 사용한다.

<br>

### find / findIndex

특정 조건에 부합하는 객채를 배열 내에서 찾기 위해서는 `arr.find`를 사용한다.

```javascript
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환한다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환한다.
});
```

요소 전체를 대상으로 함수가 순차적으로 호출된다.

- `item`
  - 함수를 호출할 요소
- `index`
  - 요소의 인덱스

- `array`
  - 배열 자기 자신

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```



`arr.findIndex`는 `find`와 동일한 동작을 하지만, 조건에 맞는 요소의 인덱스를 반환한다는 차이가 있다. 조건에 맞는 요소가 없으면 `-1`을 반환한다.

<br>

### filter

`find` 메서드는 함수의 반환 값을 `true`로 만드는 **단 하나의 요소**를 찾는다.

조건을 충족하는 요소가 여러 개라면 `arr.filter`를 사용한다.

`arr.filter`는 요소 전체를 담은 배열을 반환한다는 점에서 차이가 있다.

```javascript
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해진다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환된다.
});
```

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

<br>

## 4. 배열을 변형하는 메서드

### map

`map`은 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환한다.

```javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환한다.
});
```

<br>

### sort(fn)

`arr.sort`는 배열의 요소를 정렬해준다.

메서드를 호출하면 재정렬 된 배열이 반환되는데, `sort`를 사용하면 배열 자체가 수정되기 때문에 반환 값은 잘 사용되지 않는다.

```javascript
let arr = [ 1, 2, 15 ];

// arr 내부가 재 정렬된다.
arr.sort();

alert( arr );  // 1, 15, 2
```

요소는 문자열로 취급되어 재 정렬되기 때문에 사전편집 순으로 진행된다.

<br>

기본 정렬 기준 대신 새로운 정렬 기준을 만들려면 `arr.sort()`에 새로운 함수를 넘겨줘야 한다.

```javascript
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```



배열엔 숫자, 문자열, 객체 등이 들어갈 수 있기 때문에 **정렬 기준을 정의해주는 함수**가 필요하다.

`sort`에 정렬 함수를 인수로 넘겨주지 않으면 사전편집 순으로 요소를 정렬한다.

<br>

> **정렬 함수는 어떤 숫자든 반환할 수 있다.**

정렬 함수의 반환 값이 양수일 경우, 첫 번째 인수가 두 번째 인수보다 '크다'를 나타내고,

음수를 반환하는 경우 첫 번째 인수가 두 번째 인수보다 '작다'를 나타내기만 하면 된다.

```javascript
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

<br>

### reverse

`arr.reverse`는 `arr`의 요소를 역순으로 졍렬시킨다.

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

<br>

### split과 join

`str.split(delim)` 메서드는 구분자(delimiter) `delim`을 기준으로 문자열을 쪼깨 배열로 반환한다.

```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

<br>

`arr.join(glue)`는 `split`과 반대로 인수 `glue`를 접착제처럼 사용해 배열 요소를 모두 합친 후 하나의 문자열을 만들어준다.

```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합친다.

alert( str ); // Bilbo;Gandalf;Nazgul
```

<br>

### reduce와 reduceRight

```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

- `accumlator`
  - 이전 함수 호출의 결과
  - `initial`은 함수 최초 호출 시 사용되는 초기값을 나타낸다. (옵션)
- `item`
  - 현재 배열 요소

- `index`
  - 요소의 위치
- `array`
  - 배열

첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 **누산기(accumlator)**이다.

마지막 함수까지 호출되면 이 값은 `reduce`의 반환 값이 된다.

```javascript
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

|               | `sum` | `current` | result |
| ------------- | ----- | --------- | ------ |
| 첫 번째 호출  | `0`   | `1`       | `1`    |
| 두 번째 호출  | `1`   | `2`       | `3`    |
| 세 번째 호출  | `3`   | `3`       | `6`    |
| 네 번째 호출  | `6`   | `4`       | `10`   |
| 다섯번째 호출 | `10`  | `5`       | `15`   |

<br>

> reduce에서 초깃값을 명시하지 않을 경우

배열이 비어있는 상태일 때 초깃값이 있다면 reduce 메서드 호출 시 초깃값이 반환되는 반면, 초깃값이 없다면 에러가 발생하게 된다.



`arr.reduceRight`는 `reduce`와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다.

<br>

## 5. Array.isArray로 배열 여부 알아내기

자바스크립트에서 배열은 객체형에 속하기 때문에 `typeof`로는 일반 객체와 배열을 구분할 수 없다.

```javascript
alert(typeof {}); // object
alert(typeof []); // object
```



`Array.isArray(value)`에서 `value`가 배열이라면 `true`를, 배열이 아니라면 `false`를 반환한다.

```javascript
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

<br>

## 6. 배열 메서드와 'thisArg'

`sort`를 제외한 함수를 호출하는 대부분의 배열 메서드는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다.

```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수이다.
```

`thisArg`는 `func`의 `this`가 된다.

<br>


```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

`thisArgs`에 `army`를 지정하지 않고 `users.filter(army.canJoin)`를 사용했다면 `army.canJoin`은 단독 함수처럼 취급되고, 함수 본문 내 `this`는 `undefined`가 되어 에러가 발생한다.

`users.filter(user => army.canJoin(user))`를 사용하면 `users.filter(army.canJoin, army)`를 대체할 수 있긴 한데 `thisArg`를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용된다.