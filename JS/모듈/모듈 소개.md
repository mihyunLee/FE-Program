# 모듈 소개



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



> **모듈(module)**
>
> 개발하는 애플리케이션의 크기가 커지면서 여러 개의 파일로 분리해야할 때, 분리된 파일 각각을 **모듈**이라고 부른다.
>
> 모듈은 대개 **클래스** 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 **라이브러리** 하나로 구성된다.

<br>

## 1. 모듈이란

- 스크립트 하나는 모듈 하나이다.

- `export`와 `import`를 적용하면 다른 모듈을 불러와 불러온 모듈에 있는 함수를 호출하는 것과 같은 기능 공유가 가능하다.

  - `export` 
    - 모듈을 **내보낼 때** 쓰는 지시자
    - 변수나 함수 앞에 붙이면 외부 모듈에서 해당 변수나 함수에 접근할 수 있다.

  - `import`
    - 모듈을 **가져올 때** 쓰는 지시자
    - 외부 모듈의 기능을 가져올 수 있다.

### 예시

```javascript
// 📁 sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
```

```javascript
// 📁 main.js
import {sayHi} from './sayHi.js';

alert(sayHi); // 함수
sayHi('John'); // Hello, John!
```

- `import` 지시자는 **상대 경로**를 기준으로 모듈을 가져오고 `sayHi.js`에서 내보낸 함수 `sayHi`를 상응하는 변수에 할당한다.

<br>

### 브라우저에서 동작하는 방식

- `<script type="module">` 같은 속성을 설정해 해당 스크립트가 모듈이라는 걸 브라우저가 알 수 있게 해줘야 한다.
- 브라우저가 자동으로 모듈을 가져오고 평가한 다음, 이를 실행한다.

```html
<!doctype html>
<script type="module">
  import {sayHi} from './say.js';

  document.body.innerHTML = sayHi('John');
</script>
```

<br>

### ⚠️ 모듈은 로컬 파일에서 동작하지 않는다.

- 모듈은 `HTTP` 또는 `HTTPS` 프로토콜을 통해서만 동작한다.
- 로컬에서 `file://` 프로토콜을 사용해 웹페이지를 열면 `import`, `export` 지시자가 동작하지 않는다.

<br>

## 2. 모듈의 핵심 기능

### 1) 엄격 모드로 실행된다.

- 모듈은 항상 `엄격 모드(use strict)`로 실행된다.
- 선언되지 않은 변수에 값을 할당하는 등의 코드는 에러가 발생한다.



### 2) 모듈 레벨 스코프

- 모듈은 자신만의 스코프를 갖는다.
- 모듈 내부에서 정의한 변수나 함수는 다른 스크립트에서 접근할 수 없다.
- 외부에 내보내기 위해서는 `export` 해야 하고, 외부의 모듈을 가져와서 사용하려면 `import` 해줘야 한다.
- **부득이하게 window 레벨 전역 변수를 만들어야 한다면 `window` 객체에 변수를 명시적으로 할당하고 `window.user`와 같이 접근하는 방식을 사용할 수 있다.**  
  하지만 되도록이면 사용하지 말자.



### 3) 한 번만 평가된다.

- 모듈은 최초 호출 시 단 한번만 실행된다.

```javascript
// 📁 alert.js
alert("모듈이 평가되었습니다!");
```

```javascript
// 동일한 모듈을 여러 모듈에서 가져오기

// 📁 1.js
import `./alert.js`; // 모듈이 평가되었습니다!

// 📁 2.js
import `./alert.js`; // 아무 일도 발생하지 않음
```



- 따라서 최상위 레벨 모듈을 대개 초기화나 내부에서 쓰이는 데이터 구조를 만들고, 이를 내보내 재사용하고 싶을 때 사용한다.

```javascript
// 📁 admin.js
export let admin = {
  name: "John"
};
```

```javascript
// 📁 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// 📁 2.js
import {admin} from './admin.js';
alert(admin.name); // Pete
```

모듈은 단 한 번만 실행되고 실행된 모듈은 필요한 곳에 공요된다.

따라서 어느 한 모듈에서 `admin` 객체를 수정하면 다른 모듈에서도 변경사항을 확인할 수 있다.



### 4) import.meta

- `import.meta` 객체는 현재 모듈에 대한 정보를 제공해준다.
- 호스트 환경에 따라 제공하는 정보의 내용은 다른데, 브라우저 환경에선 스크립트의 URL 정보를 얻을 수 있다.
- HTML 안에 있는 모듈이라면, 현재 실행 중인 웹 페이지의 URL 정보를 얻을 수 있다.

```html
<script type="module">
  alert(import.meta.url); // script URL (인라인 스크립트가 위치해 있는 html 페이지의 URL)
</script>
```



### 5) this는 undefined

- 모듈 최상위 레벨의 `this`는 `undefined`이다.
- 모듈이 아닌 일반 스크립트의 `this`는 전역 객체인 것과 대조된다.

```html
<script>
  alert(this); // window
</script>

<script type="module">
  alert(this); // undefined
</script>
```

<br>

## 3. 브라우저 특정 기능

### 1) 지연 실행

- 모듈 스크립트는 **항상** 지연 실행된다.

- 외부 스크립트, 인라인 스크립트와 관계없이 마치 `defer` 속성을 붙인 것 처럼 실행된다.



#### 모듈 스크립트의 특징

- 외부 모듈 스크립트 `<script type="module" src="...">`를 다운로드 할 때 브라우저의 HTML 처리가 멈추지 않는다.
  브라우저는 외부 모듈 스크립트와 기타 리소스를 병렬적으로 불러온다.
- 모듈 스크립트는 대기 상태에 있다가 HTML 문서가 완전히 만들어진 이후에 실행된다.
- 스크립트의 상대적 순서가 유지되어 문서상 위쪽의 스크립트부터 차례로 실행된다.
- 모듈이 완전히 로딩되기 전에 페이지가 먼저 사용자에게 노출되면 사용자가 혼란을 느낄 수 있기 때문에 모듈 스크립트를 불러오는 동안엔 투명 오버레이나 `로딩 인디케이터(loading indicator)`를 보여주어 사용자의 혼란을 예방해주어야 한다.

<br>

### 2) 인라인 스크립트의 비동기 처리

- 모듈이 아닌 일반 스크립트에서 `async` 속성은 외부 스크립트를 불러올 때만 유효하다.
- 반면, 모듈 스크립트에선 `async` 속성을 인라인 스크립트에도 적용할 수 있다.
- 스크립트에 `async` 속성이 붙으면 다른 스크립트나 HTML이 처리되길 기다리지 않고 바로 실행된다.
- 이 기능은 광고나 문서 레벨 이벤트 리스너, 카운터 같이 어디에도 종속되지 않는 기능을 구현할 때 유용하게 사용할 수 있다.

```html
<!-- 필요한 모듈(analytics.js)의 로드가 끝나면 -->
<!-- 문서나 다른 <script>가 로드되길 기다리지 않고 바로 실행된다.-->
<script async type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
```

<br>

### 3) 외부 스크립트

- `src` 속성값이 동일한 외부 스크립트는 한 번만 실행된다.

```html
<!-- my.js는 한 번만 로드 및 실행된다.-->
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```

- 외부 사이트 같이 다른 오리진에서 모듈 스크립트를 불러오려면 **CORS 헤더**가 필요하다.

- 모듈이 저장되어있는 원격 서버가 `Access-Control-Allow-Origin: *` 헤더를 제공해야만 외부 모듈을 불러올 수 있다.

- `*` 대신 페치(fetch)를 허용할 도메인을 명시할 수도 있다..

  ```html
  <!-- another-site.com이 Access-Control-Allow-Origin을 지원해야만 외부 모듈을 불러올 수 있다.-->
  <!-- 그렇지 않으면 스크립트는 실행되지 않는다.-->
  <script type="module" src="http://another-site.com/their.js"></script>
  ```



### 4) 경로가 없는 모듈은 금지

- 브라우저 환경에서 `import`는 반드시 상대 혹은 절대 URL 앞에 와야한다.
- Node.js나 번들링 툴은 경로가 없어도 해당 모듈을 찾을 수 있는 방법을 알기 때문에 경로가 없는 모듈을 사용할 수 있지만, 브라우저는 경로 없는 모듈을 지원하지 않는다.



### 5) 호환을 위한 nomodule

- 구식 브라우저는 `type="module"`을 해석하지 못하게 때문에 모듈 타입의 스크립트를 만나면 이를 무시하고 넘어간다.
- `nomodule` 속성을 사용하면 이런 상황을 대비할 수 있다.

<br>

## 4. 빌드 툴

- 브라우저 환경에서는 **[웹팩(Webpack)](https://webpack.js.org/)**과 같은 툴을 사용해 모듈을 한데 묶어(번들링) 프로덕션 서버에 올리는 방식을 사용한다.

- 번들러를 사용하면 모듈 분해를 통제할 수 있고, 경로가 없는 모듈이나 CSS, HTML 포맷의 모듈을 사용할 수 있게 해준다는 장점이 있다.

### 빌드 툴의 역할

- HTML의 `<script type="module">`에 넣을 주요 모듈(진입점 역할을 하는 모듈)을 선택한다.
- 주요 모듈에 의존하고 있는 모듈 분석을 시작으로 모듈 간의 의존 관계를 파악한다.
- 모듈 전체를 한데 모아 하나의 큰 파일을 만든다. 이 과정에서 `import` 문이 번들러 내 함수로 대체되므로 기존 기능은 그대로 유지된다.
- 변형이나 최적화가 함께 수행된다.
  - 도달 가능하지 않은 코드는 삭제
  - 내보내진 모듈 중 쓰임처가 없는 모듈을 삭제
  - `console`, `debugger` 같은 개발 관련 코드 삭제
  - 최신 자바스크립트 문법이 사용된 경우 **바벨(babel)**을 사용해 동일한 기능을 하는 낮은 버전의 스크립트로 변환
  - 공백 제거, 변수 이름 줄이기 등으로 산출물의 크기를 줄인다.
- 번들링 과정을 거치면 모듈이 일반 스크립트가 되어버리긴 하지만 네이티브 모듈도 당연히 사용가능하다.