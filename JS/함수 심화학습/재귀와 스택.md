# 재귀와 스택



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



> 재귀란?

함수에서 다른 함수를 호출할 때, 함수가 **자기 자신**을 호출하는 경우 이를 **재귀**라고 한다.

<br>

## 1. 두 가지 사고방식

- Ex. `x`를 `n`번 제곱해주는 함수 `pow(x, n)`

1. 반복문 - `for`

```javascript
function pow(x, n) {
  let result = 1;

  // 반복문을 돌면서 x를 n번 곱함
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
```

2. 재귀함수

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```

`pow`는 `n == 1`이 될 때까지 재귀적으로 자신을 호출한다. `n == 1`일 때 명확한 결괏값을 즉시 도출하기 때문에 **재귀의 베이스(base)** 라 하고 n == 1이 아닐 떄 `x * pow(x, n-1)` 은 **재귀 단계(recursive step)** 라고 부른다.

<br>

- 재귀 깊이(recursion depth)

가장 처음 하는 호출을 포함한 중첩 호출의 최대 개수를 **재귀 깊이**라고 한다. `pow(x, n)`의 재귀 깊이는 `n`이다. 자바스크립트 엔진은 최대 재귀 깊이를 제한한다. 만개 정도에서 엔진에 따라 십만까지만 다룰 수 있다.

<br>

## 2. 실행 컨텍스트와 스택

실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 **실행 컨텍스트(execution context)** 에 저장된다.

실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, `this`의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.

함수 호출 1회 당 정확히 하나의 실행 컨텍스트가 생성된다.

- 함수 내부에 중첩 호출이 있을 때의 절차
  - 현재 함수의 실행이 일시 중지된다.
  - 중지된 함수와 연관된 실행 컨텍스트는 **실행 컨텍스트 스택(execution conext stack)** 이라는 자료 구조에 저장된다.
  - 중첩 호출 실행
  - 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

재귀 깊이는 스택에 들어가는 실행 컨텍스트 수의 최댓값과 같다. 실행 컨텍스트는 메모리를 차지하기 때문에 재귀를 사용할 땐 메모리 요구사항에 유의해야한다.

반복문을 사용하면 대개 **함수 호출의 비용**(메모리 사용)이 절약되고, 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다. 최적화를 하더라도 큰 개선이 없는 경우에는 재귀를 사용하는 것이 더 좋다.

<br>

## 3. 재귀적 구조

재귀적으로 정의된 자료구조인 **재귀적 자료 구조**는 자기 자신의 일부를 복제하는 형태의 자료 구조이다.

HTML과 XML도 재귀적 자료 구조 형태를 띤다. HTML 문서에서 HTML 태그는 `일반 텍스트`, `HTML - 주석`, `이외의 HTML 태그` 로 구성되기 때문이다.

<br>

### 연결 리스트

객체를 정렬하여 어딘가에 저장하고 싶을 때, **배열**을 사용할 수 있다. 하지만 배열은 삭제와 삽입시 모든 요소의 번호를 다시 매기기 때문에 비용이 많이 든다.

빠르게 삽입 혹은 삭제를 해야할 때는 **연결 리스트(linked list)** 라 불리는 자료 구조를 사용할 수 있다.

<br>

연결 리스트의 요소는 객체와 아래 프로퍼티들을 조합해 정의할 수 있다.

- `value`
- `next` - 다음 연결 리스트 요소를 참조하는 프로퍼티로 다음 요소가 없을 땐 `null`이 된다.

<br>

```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

// 위와 동일한 연결 리스트를 만든다.
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

![image-20220818162539781](https://user-images.githubusercontent.com/51310674/185345341-e4ca3254-0c99-4ffc-949a-1d621e241833.png)

연결 리스트를 만들면 객체가 여러개 있고, 각 객체엔 `value`와 이웃 객체를 가리키는 프로퍼티인 `next`가 있는 게 명확히 보인다. 체인의 시작 객체는 변수 `list`에 저장되어 있고, `list`의 `next`프로퍼티를 이용해 이어지는 객체 어디든 도달할 수 있다.



- 연결 리스트 분리

```javascript
let secondList = list.next.next;
list.next.next = null;
```

![image-20220818165946103](https://user-images.githubusercontent.com/51310674/185345390-2b4e533f-6dcb-406e-bafc-d2539ff304d3.png)

- 연결 리스트 합치기

```javascript
list.next.next = secondList;
```

- 연결 리스트에 요소 추가, 삭제
  - 리스트의 처음 객체를 바꿔 리스트 맨 앞에 새로운 값 추가

```javascript
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// list에 새로운 value를 추가합니다.
list = { value: "new item", next: list };
```

![image-20220818170111588](https://user-images.githubusercontent.com/51310674/185345424-645ef97c-d72c-4c90-af73-0374ef2227cf.png)

- 연결 리스트 중간 요소 제거
  - 이전 요소의 `next`를 변경하기
  - 제거되는 객체는 따로 저장되지 않으면 자동으로 메모리에서 제거된다.

```javascript
list.next = list.next.next;
```

![image-20220818170222300](https://user-images.githubusercontent.com/51310674/185345447-57a99e26-284a-46ea-bca3-0e0407b3619a.png)



연결 리스트는 배열과는 달리 대량으로 요소 번호르 재할당하지 않으므로 요소를 쉽게 재배열 할 수 있다. 하지만, 배열의 `arr[n]`처럼 인덱스만 사용해 요소에 접근할 수 없다는 단점이 있다.

- 연결 리스트 기능 개선
  - 이전 요소를 참조하는 프로퍼티 `prev`를 추가하면 이전 요소로 쉽게 이동할 수 있다.
  - 리스트의 마지막 요소를 참조하는 변수 `tail`을 추가할 수 있다. 다만 리스트 마지막에 요소를 추가하거나 삭제할 때 `tail`도 갱신해줘야 한다.
