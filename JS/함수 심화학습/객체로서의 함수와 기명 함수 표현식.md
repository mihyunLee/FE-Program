# 객체로서의 함수와 기명 함수 표현식



> 출처 - [**모던 JS 튜토리얼**](https://ko.javascript.info/)을 보고 정리한 글입니다.



<br>



## 1. name 프로퍼티

- 함수 객체에서 `name` 프로퍼티를 사용하면 함수 이름을 가져올 수 있다.

  - 익명 함수, 기본값을 이용해 이름을 할당한 경우에도 가능
  - 자바스크립트 명세서에서 정의된 이 기능을 `contextual name`이라고 부른다.
    이름이 없는 함수의 이름을 지정할 땐 컨텍스트에서 이름을 가져온다.

  ```javascript
  function sayHi() {
    alert("Hi");
  }
  
  alert(sayHi.name); // sayHi
  ```

- 객체 메서드 이름은 함수처럼 자동 할당 되지 않아서 이때 `name` 프로퍼티엔 빈 문자열이 저장된다.

<br>

## 2. length 프로퍼티

- `length` 프로퍼티는 함수 매개변수의 개수를 반환한다.
  - 나머지 매개변수는 개수에 포함되지 않는다.
- 다른 함수 안에서 동작하는 함수의 **타입을 검사(type introspection)** 할 때도 종종 사용된다.
  - 아래 코드처럼 인수의 종류에 따라 인수를 다르게 처리하는 방식을 프로그래밍 언어에선 `다형성(polymorphism)`이라고 부른다.

```javascript
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

ask("질문 있으신가요?", () => alert('OK를 선택하셨습니다.'), result => alert(result));
```

<br>

## 3. 커스텀 프로퍼티

- 함수에 자체적으로 만든 프로퍼티를 추가할 수 있다.
- 아래의 코드에서 함수에 프로퍼티를 할당해도 함수 내에 지역변수 `counter`가 만들어지지 않는다.

```javascript
function sayHi() {
  alert("Hi");
    
  sayHi.counter++;
}
sayHi.counter = 0; // 초깃값

sayHi(); // Hi
sayHi(); // Hi

alert( `호출 횟수: ${sayHi.counter}회` ); // 호출 횟수: 2회
```

- 클로저는 함수 프로퍼티로 대체할 수 있다.

```javascript
function makeCounter() {

  // let count = 0 대신 아래 메서드(프로퍼티)를 사용

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1

counter.count = 10;
alert( counter() ); // 10
```

`count`는 외부 렉시컬 환경이 아닌 함수 프로퍼티에 바로 저장된다.

**클로저**를 사용한 경우엔 외부 코드에서 `count`에 접근할 수 없고 중첩함수 내에서만 `count` 값을 수정할 수 있다. 반면 **함수 프로퍼티**를 사용해 `count`를 함수에 바인딩시킨 경우엔 외부에서 값을 수정할 수 있다.

<br>

## 4. 기명 함수 표현식

> 기명 함수 표현식(Named Function Expression, NFE) 이란?

이름이 있는 함수 표현식을 나타내는 용어이다.

- 이름을 사용해 함수 표현식 내부에서 자기 자신을 참조할 수 있다.
- 기명 함수 표현식 외부에선 그 이름을 사용할 수 없다.
- 함수 선언문에는 내부 이름을 지정할 수 없다.

```javascript
// 일반 함수 표현식
let sayHi = function(name) {
  alert(`Hello, ${name}`);
};

// 기명 함수 표현식
let sayHi = function func(name) {
  alert(`Hello, ${name}`);
};
```

<br>

### 예시

```javascript
let sayHi = function func(name) {
  if (name) {
    alert(`Hello, ${name}`);
  } else {
    func("Guest"); // func를 사용해서 자신을 호출
  }
};

sayHi(); // Hello, Guest
func(); // Error, func is not defined (기명 함수 표현식 외부에선 이름을 사용할 수 없다.)
```

중첩 호출 시에 `sayHi` 대신 이름을 지어 `func`와 같이 호출하는 이유는 외부 코드에 의해 `sayHi`가 변경될 경우 에러가 발생할 수 있기 때문이다.

```javascript
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // TypeError: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // 중첩 sayHi 호출은 더 이상 불가능
```

함수가 `sayHi`를 자신의 외부 렉시컬 환경에서 가지고 오는데, 함수 호출 시점에 외부 렉시컬 환경의 `sayHi`엔 `null`이 저장되어 있기 때문에 에러가 발생한다.